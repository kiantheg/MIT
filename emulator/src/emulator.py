#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""PulsON 440 radar emulator class and command line execution."""

__author__ = 'Ramamurthy Bhagavatula Mason Mitchell, Winston Liu'
__version__ = '1.0'
__maintainer__ = 'Ramamurthy Bhagavatula'
__email__ = 'ramamurthy.bhagavatula@ll.mit.edu'

"""References
[1] Monostatic Radar Application Programming Interface (API) Specification
    PulsON (R) 400 Series
    Version: 1.2.2
    Date: January 2015
    https://timedomain.com/wp-content/uploads/2015/12/320-0298E-MRM-API-Specification.pdf
"""


# Import required modules and methods
import argparse
from constants import DEFAULT_CONFIG, DEFAULT_STATUS, IDLE_TIMEOUT, MAX_PACKET_SIZE, \
    FOREVER_SCAN_COUNT, STOP_SCAN_COUNT, T_BIN, DN_BIN, SEG_NUM_BINS, IMPULSE_RATE, RAKE_SIZE, \
    TX_GAIN_MAP, RADAR_IP, RADAR_PORT, RESERVED_VAL, BYTE_ORDER, SPEED_OF_LIGHT
from collections import OrderedDict
from copy import deepcopy
import datetime
from formats import ALL_MRM_MESSAGES
from helper_functions import setup_logger, close_logger, parse_mission
import logging
import math
import numpy as np
from pathlib import Path
import pickle
from scipy import interpolate
from scipy.spatial.distance import cdist
import socket
import sys
import time
import yaml

# Constants
MIN_PII = ALL_MRM_MESSAGES['MRM_SET_CONFIG_REQUEST']['packet_def']['pii'][2][0] # Minimum allowable PII
MAX_MSG_ID = 2**16 - 1 # Maximum message ID value before wrapping
SCAN_DATA_MIN = -2**31 # Minimum and maximum scan data values
SCAN_DATA_MAX = 2**31 - 1

# Emulator settings
MSG_QUEUE_SIZE = 20 # Maximum number of messages to queue before transmitting at least the first

# Default directories and files
CONFIG_DIR = Path(__file__).resolve().parents[1] / 'config'
INPUT_DIR = Path(__file__).resolve().parents[1] / 'input'
OUTPUT_DIR = Path(__file__).resolve().parents[1] / 'output'
DEFAULT_SCATTERERS = 'scatterers.yml'
DEFAULT_MISSION = 'mission.yml'

# Event settings
BIT_FAIL_PROB = 0.1 # BIT failure
DROP_MSG_PROB = 0.01 # Dropped messages
OUT_OF_ORDER_MSG_PROB = 0.01 # Out-of-order messages
OUT_OF_ORDER_WINDOW = 10 # Number of sequential messages in message queue to consider swapping amongst

# Custom logging
# REFERENCE provides needed information
REFERENCE_LEVEL = 24
logging.addLevelName(REFERENCE_LEVEL, 'REFERENCE')
def reference(self, msg, *args, **kwargs):
    if self.isEnabledFor(REFERENCE_LEVEL):
        self._log(REFERENCE_LEVEL, msg, args, **kwargs) 
logging.Logger.reference = reference
# STATE advertises emulator state
STATE_LEVEL = 28
logging.addLevelName(STATE_LEVEL, 'STATE')
def state(self, msg, *args, **kwargs):
    if self.isEnabledFor(STATE_LEVEL):
        self._log(STATE_LEVEL, msg, args, **kwargs) 
logging.Logger.state = state


class Emulator:
    """Class for PulsON 440 radar emulator."""
    
    def __init__(self, logger=None, op_mode='develop', data_mode='ramp', offline_data='',
                 scatterers=DEFAULT_SCATTERERS, mission=DEFAULT_MISSION, idle_timeout = IDLE_TIMEOUT, 
                 emulator_ip=RADAR_IP, emulator_port=RADAR_PORT, add_noise=False, 
                 noise_mag=2**(MIN_PII - 1), prop_loss=False, beam_rolloff=False,
                 bit_fail_prob=BIT_FAIL_PROB, drop_msg_prob=DROP_MSG_PROB, 
                 out_of_order_msg_prob=OUT_OF_ORDER_MSG_PROB):
        """Emulator instance initialization.
        
        Args:
            logger (logging.Logger)
                Configured logger. Defaults to None.
                
            op_mode (str)
                Emulator operational mode. Options are {'develop', 'test', 'real'}. Defaults to
                'develop'
            
            data_mode (str)
                Emulator data mode. Options are {'constant', 'ramp', 'offline', 'realtime'}. 
                Defaults to 'ramp'.
                
            offline_data (str)
                Path to file containing data to use in 'offline' data mode. Must be in same format 
                as data generated by simulate_sar_data.py.
            
            scatterers (str)
                Path to YAML file specifying scatterers used in 'realtime' data mode. Exact format 
                is self-evident from the example file provided and also detailed in README. 
                Defaults to DEFAULT_SCATTERERS.
            
            mission (str)
                Path to YAML file specifying mission in terms of platform path waypoints, velocities, 
                radar orientation, and regions-of-interest. Defaults to DEFAULT_MISSION.
            
            idle_timeout (float)
                Timeout (s) of emulator inactivity before it shuts itself down. Defaults to 
                IDLE_TIMEOUT.
            
            emulator_ip (str)
                IP address of radar that host should target. Defaults to RADAR_IP.
                
            emulator_port (int)
                Port on radar that host should target. Defaults to RADAR_PORT.
                
            add_noise (bool)
                Indicates whether or not to add noise to data generated via 'offline' or 'realtime'
                data modes. Defaults to False.
                
            noise_mag (float)
                Magnitude of generated noise. Defaults to 2**(MIN_PII - 1).
                
            prop_loss (bool)
                Indicates whether or not to include range propagation loss. Default to False.
                
            beam_rolloff (bool)
                Indicates whether ot not to include beam rolloff loss. Defaults to False.
                
            bit_fail_prob (float)
                Probability of a BIT failure occurring. Defaults to BIT_FAIL_PROB.
                
            drop_msg_prob (float)
                Probability of a dropped message/packet occurring. Defaults to DROP_MSG_PROB.
                
            out_of_order_msg_prob (float)
                Probability of an out-of-order message/packet occurring. Defaults to 
                OUT_OF_ORDER_MSG_PROB.
        """
        # Radar emulator status indicators
        self.open = False
        self.boot_time = None
        self.receive_msg_count = 0
        self.send_msg_count = 0
        
        # Radar system parameters
        self.range_bin_size = SPEED_OF_LIGHT * T_BIN * 1e-9 / 2 # Range bin size (m)
        self.sampling_window = 1000 * DN_BIN * T_BIN # Sampling time window (ps)
        self.rake_steps_per_window = math.floor(self.sampling_window / RAKE_SIZE) # Number of rake steps per window
        
        # Connection
        self.connection = {
                'emulator_address': (emulator_ip, emulator_port), # Emulator and host addresses
                'host_address': None,
                'socket': None} # UDP socket
        
        # Radar internal configuration
        self.op_mode = op_mode
        self.config = DEFAULT_CONFIG
        self.status = DEFAULT_STATUS
        self.bit_fail_prob = bit_fail_prob
        self.drop_msg_prob = drop_msg_prob
        self.out_of_order_msg_prob = out_of_order_msg_prob
        self.data_mode = data_mode
        self.first_boot = True
        self.bit_result = None
        
        # Stability settings
        self.idle_timeout = idle_timeout
        
        # Event/data variables
        self.rng = np.random.default_rng()
        self.msg_id_order = []
        self.dropped_msg_ids = []
        
        # Message queue
        self.msg_queue = []
        self.payload_queue = []
        self.msg_name_queue = []
        
        # Scan variables
        self.scan_count = 0
        self.start_msg_id = 0
        self.total_gain = 1
        self.tx_gain = 1
        self.int_gain = 1
        self.scan_stop = None
        self.num_samples_total = 0
        self.num_msgs_per_scan = 0
        self.num_samples_per_msg = []
        self.range_start = 0
        self.range_bin_size = 0
        self.range_bins = []
        self.range_bins_per_msg = []
        self.range_bin_idx = []
        self.scan_interval = None
        self.prev_amp = 0
        self.amp_dir = 1
        self.scan_wrap = 0
        self.num_scans = 0
        
        # Noise, propagation loss, and beam rolloff
        self.add_noise = add_noise
        self.noise_mag = noise_mag
        self.noise_var = 0
        self.prop_loss = prop_loss
        self.beam_rolloff = beam_rolloff
        
        # Offline radar data
        self.offline_data_file = Path(offline_data).resolve()
        self.offline_scan_data = None
        self.offline_platform_pos = None
        self.offline_range_bins = None
        self.offline_timestamps = None
        self.offline_data_interp = None
        self.offline_platform_pos_interp = None
        
        # Real-time radar data
        self.scatterers_file = Path(scatterers).resolve()
        self.scatterers = []
        self.realtime_scan_data = []
        self.realtime_max_num_scans = 0
        
        # Mission
        self.mission_file = Path(mission).resolve()
        self.mission = []
        
        # Platform positions
        self.platform_pos = []
        
        # Mapping of host-to-radar messages to radar-to-host responses
        self.response_mapping = {
            'MRM_SET_CONFIG_REQUEST': self.set_radar_config_request_response,
            'MRM_GET_CONFIG_REQUEST': self.get_radar_config_request_response,
            'MRM_CONTROL_REQUEST': self.control_request_response,
            'MRM_GET_STATUSINFO_REQUEST': self.get_statusinfo_request_response,
            'MRM_REBOOT_REQUEST': self.reboot_request_response,
            'MRM_COMM_CHECK_REQUEST': self.comm_check_request_response}
        
        # Logger
        self._logger = None
        self.logger = logger
        
    def __del__(self):
        """Clean up actions upon object deletion."""
        if self.open:
            self.close_connection()
            
            
    """logger property decorators. Setter validates value is a valid logger."""
    @property
    def logger(self):
        return self._logger
    
    
    @logger.setter
    def logger(self, value):
        if value is None:
            self._logger = logging.getLogger('trash')
            self._logger.propagate = False
        elif not issubclass(type(value), logging.getLoggerClass()):
            raise TypeError("Specified logger of incorrect type; expecting subclass of " + 
                            "logging.Logger!")
        else:
            self._logger = value
            
            
    def init_radar_data(self):
        """Initialize data sources depending on data mode.
        
        Raises:
            FileNotFoundError if offline data file does not exist in 'offline' data mode.
            FileNotFoundError if realtime scatterers file does not exist in 'realtime' data mode.
        """
        # Offline or real-time data modes
        if self.data_mode in ['offline', 'realtime']:
            self.logger.state("INITIALIZING radar data...")
            # Noise parameters
            if self.add_noise:
                self.noise_var = self.noise_mag / math.sqrt(2)
                
            # Offline data mode
            if self.data_mode == 'offline':
                self.logger.debug("Initializing offline radar data from "
                                  f"'{self.offline_data_file}'...")
                if not self.offline_data_file.exists():
                    raise FileNotFoundError("Offline radar data file "
                                            f"'{self.offline_data_file} cannot be found!")
                with open(self.offline_data_file, 'rb') as f:
                    offline_data = pickle.load(f)
                # Normalize scan data to be in [-1, 1] range
                self.offline_scan_data = deepcopy(offline_data['scan_data'])
                if np.iscomplexobj(self.offline_scan_data):
                    self.offline_scan_data = np.abs(self.offline_scan_data)
                    self.offline_scan_data /= np.amax(self.offline_scan_data)
                else:
                    self.offline_scan_data /= np.amax(np.abs(self.offline_scan_data))
                # Platform position (m) and range bins (m)
                self.offline_platform_pos = offline_data['platform_pos']
                self.offline_range_bins = offline_data['range_bins']
                # Calculate timestamps (s) based on PRF/scanning rate
                self.offline_timestamps = (np.arange(0, self.offline_scan_data.shape[0]) / 
                                           offline_data['sim_params']['scan_rate'])
                # Radar data interpolator
                self.offline_data_interp = interpolate.interp2d(self.offline_range_bins, 
                                                                self.offline_timestamps, 
                                                                self.offline_scan_data, 
                                                                kind='linear', copy=False, 
                                                                bounds_error=False, fill_value=0)
                
            # Real-time data mode
            elif self.data_mode == 'realtime':
                self.logger.debug("Initializing real-time scatterers from "
                                  f"'{self.scatterers_file}'...")
                # Read in real-time scatterers file
                if not self.scatterers_file.exists():
                    raise FileNotFoundError(f"Real-time scatterers file "
                                            f"'{self.scatterers_file} cannot be found!")
                with open(self.scatterers_file, 'r') as f:
                    self.scatterers = yaml.load(f, Loader=yaml.FullLoader)
                self.scatterers['pos_rcs'] = \
                    np.asarray(self.scatterers['pos_rcs'])
                # TODO Generate random scatterers
            self.logger.state("INITIALIZED radar data.")
            
            
    def init_platform_pos(self):
        """Initialize platform positions depending on data mode.
        
        Raises:
            FileNotFoundError if mission file does not exist in 'realtime' data mode.
        """
        # Offline or real-time data modes
        if self.data_mode in ['offline', 'realtime']:
            self.logger.state("INITIALIZING platform positions...")
            ref_datetime = datetime.datetime.now()
            datetime_str = ref_datetime.strftime('%Y%m%dT%H%M%S')
            
            # Offline data mode
            if self.data_mode == 'offline':
                self.logger.debug("Initializing platform positions from offline data file "
                                  f"'{self.offline_data_file}'")
                # File to save platform positions to
                self.platform_pos_file = \
                    OUTPUT_DIR.joinpath(f"{datetime_str}_{self.offline_data_file.stem}_platform_pos.pkl")
                # Platform position interpolator
                self.offline_platform_pos_interp = interpolate.interp1d(self.offline_timestamps, 
                                                                        self.offline_platform_pos,
                                                                        axis=0, copy=False,
                                                                        bounds_error=False, 
                                                                        fill_value='extrapolate')
                
            # Real-time data mode
            if self.data_mode == 'realtime':
                self.logger.debug("Initializing platform positions from mission file "
                                  f"'{self.mission_file}'...")
                # File to save platform positions to
                self.platform_pos_file = \
                    OUTPUT_DIR.joinpath(f"{datetime_str}_{self.mission_file.stem}_platform_pos.pkl")
                # Read in mission file
                if not self.mission_file.exists():
                    raise FileNotFoundError(f"Mission file '{self.mission_file}' cannot be found!")
                with open(self.mission_file, 'r') as f:
                    self.mission = yaml.load(f, Loader=yaml.FullLoader)
                self.mission['waypoints_pos_vel'] = np.asarray(self.mission['waypoints_pos_vel'])
                self.mission['init_xy_heading'] = np.asarray(self.mission['init_xy_heading'])
                self.mission['beamwidth'] = np.radians(self.mission['beamwidth'])
            self.logger.state("INITIALIZED platform positions.")
            
                
    def boot(self):
        """Boots emulator.
        
        Raises:
            KeyError if unrecognized operational mode specified.
        """
        self.logger.state("BOOTING...")
        # Tracking variables
        self.boot_time = time.time() * 1000
        self.receive_msg_count = 0
        self.send_msg_count = 0
        # BIT failure and event probabilities depending on operational mode
        if self.op_mode == 'develop':
            self.bit_result = 0
            self.drop_msg_prob = 0
            self.out_of_order_msg_prob = 0
        elif self.op_mode in ['test', 'real']:
            self.bit_result = self.rng.binomial(1, self.bit_fail_prob)
        else:
            raise KeyError(f"Unrecognized emulator operational mode of '{self.op_mode}' specified!")
        # Initialize radar data and platform position if this is first boot
        if self.first_boot:
            self.init_radar_data()
            self.init_platform_pos()
            self.first_boot = False
        # Initialize output directory
        self.logger.debug(f"Making emulator output directory '{OUTPUT_DIR}' if needed.")
        OUTPUT_DIR.mkdir(exist_ok=True)
        # Finish boot and open connection for host
        self.logger.state(f"BOOTED in '{self.op_mode}' operational mode.")
        self.open_connection()
        
        
    def encode_msg(self, raw_payload, msg_format, msg_name):
        """Encode radar to host message.
        
        Args:
            raw_payload (OrderedDict)
                Specifies the payload to encode. Each key must match exactly a key in packet_def
                contained in msg_format.
            
            msg_format (OrderedDict)
                Message format as defined in formats.py.
                
            msg_name (str)
                Message name as defined in formats.py.
        
        Returns:
            msg (bytes)
                The payload encoded into a byte sequence for transmission to the host.
                
            sent_payload (OrderedDict)
                Payload encoded into message that accounts for any error/case handling.
        """
        # Set deep copy of payload to avoid malforming original
        payload = deepcopy(raw_payload)
        payload['message_type'] = msg_format['message_type']
        
        # Add all packet fields to message
        msg = b''
        for packet_field in msg_format['packet_def'].keys():
            dtype = msg_format['packet_def'][packet_field][0]
            max_count = msg_format['packet_def'][packet_field][1]
            # Check if packet field has valid value
            if payload[packet_field] is None:
                self.logger.debug(f"Packet field '{packet_field}' of message {msg_name} has no "
                                  "value specified; will default to 0.")
                payload[packet_field] = 0 if max_count == 1 else [0] * max_count
            # Treat packet fields that can have more than one element separately
            if max_count > 1:
                field_payload_length = len(payload[packet_field])
                if field_payload_length > max_count:
                    self.logger.debug(f"Packet field '{packet_field}' of message {msg_name} " 
                                      f"has a payload of length {field_payload_length} that "
                                      f"exceeds the maximum allowable element count of {max_count}; " 
                                      "will be truncated to that length.")
                
                for idx in range(min(max_count, field_payload_length)):
                    msg += (payload[packet_field][idx]).to_bytes(length=dtype.itemsize, 
                                                                 byteorder=BYTE_ORDER, 
                                                                 signed=np.issubdtype(dtype, np.signedinteger))
            else:
                msg += (payload[packet_field]).to_bytes(length=dtype.itemsize, 
                        byteorder=BYTE_ORDER, signed=np.issubdtype(dtype, np.signedinteger))
        return msg, payload
    
    
    def decode_msg(self, msg):
        """Decode host to radar message.
        
        Args:
            msg (bytes)
                Message byte sequence received from host.
                
        Returns:
            msg_name (str)
                Message name as defined by API.
            
            payload (OrderedDict)
                Payload decoded from message received from host.
                
            status (int)
                Status as a result of checking if message was right size. In accordance w/ [1], 
                returns a 0 if successful and a 5 if not.
                
        Raises:
            NotImplementedError if message's apparent type does not match any implemented.
        """
        self.logger.debug(f"Decoding following message --> {msg}")
        # Determine message type
        msg_type = int.from_bytes(msg[0:2], byteorder=BYTE_ORDER, signed=False)
        msg_match = [(msg_name, msg_format)  
                     for msg_name, msg_format in ALL_MRM_MESSAGES.items()
                     if msg_format['message_type'] == msg_type]
        if not msg_match:
            raise NotImplementedError(f"Message's apparent type {msg_type} does not match any "
                                      "known/implemented!")
        else:
            msg_name = msg_match[0][0]
            msg_format = msg_match[0][1]
            
        # Initialize decoded payload
        payload = OrderedDict.fromkeys(msg_format['packet_def'])
        
        # Determine status
        if len(msg) != msg_format['packet_length']:
            status = 5
        
        # Iterate over each field in packet definition
        else:
            byte_counter = 0
            status = 0
            for packet_field, field_settings in msg_format['packet_def'].items():
                
                try:
                    # Convert to non-byte representation
                    dtype = field_settings[0]
                    bounds = field_settings[2]
                    num_bytes = dtype.itemsize
                    payload[packet_field] = int.from_bytes(
                        msg[byte_counter:(byte_counter + num_bytes)], byteorder=BYTE_ORDER, 
                        signed=np.issubdtype(dtype, np.signedinteger))
                    byte_counter += num_bytes
                    
                    # Check if bounds are met
                    if bounds is not None:
                        if payload[packet_field] < bounds[0] or payload[packet_field] > bounds[1]:
                            status = 3
                except:
                    status = 3
                    
            if status != 0:
                self.logger.debug(f"{msg_name} could not be decoded properly/validly; response "
                                  "will be null.")
                
        return msg_name, payload, status
    
    
    def open_connection(self):
        """Open connection for host to connect to."""
        if self.open:
            self.logger.debug("Connection already open for host!")
        else:
            self.logger.state("OPENING connection for host...")
            self.logger.debug(f"Emulator address --> {self.connection['emulator_address']}.")
            self.connection['socket'] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.connection['socket'].settimeout(self.idle_timeout)
            self.connection['socket'].bind(self.connection['emulator_address'])
            self.open = True
            self.logger.state("OPENED connection for host.")
            
            
    def close_connection(self):
        """Close connection to host."""
        if not self.open:
            self.logger.debug("No connection to host exists to close!")
        else:
            self.logger.state("CLOSING connection to host...")
            self.connection['socket'].close()
            self.open = False
            self.logger.state("CLOSED connection to host.")
            
            
    def init_confirm_payload(self, request_payload, request_status, msg_name):
        """Initializes confirm payload based on request payload.
        
        Args:
            request_payload (OrderedDict)
                Payload decoded from host request. Used to configure certain portions of response 
                message.
                
            request_status (int)
                Status of request as thus far determined by its decoding.
                
            msg_name (str)
                Message name as defined by API.
                
        Returns:
            confirm_payload (OrderedDict)
                Initialized confirm payload.
        """
        confirm_payload = OrderedDict.fromkeys(ALL_MRM_MESSAGES[msg_name]['packet_def'])
        confirm_payload['message_type'] = ALL_MRM_MESSAGES[msg_name]['message_type']
        confirm_payload['message_id'] = request_payload['message_id']
        confirm_payload['status'] = request_status
        return confirm_payload
    
    
    def queue_msg(self, raw_payload, msg_name, process=False):
        """Encode payload into message and send to host if message queue is full or if at front.
        
        Args:
            raw_payload (OrderedDict)
                Specifies the payload to encode. 
            
            msg_name (str)
                Message name as defined in formats.py.
                
            process (false)
                Whether or not to queue amd process message at the front.
        """
        # Encode payload into message and add to queue
        msg, payload = self.encode_msg(raw_payload, ALL_MRM_MESSAGES[msg_name], msg_name)
        pos = 0 if process else len(self.msg_queue)
        self.msg_queue.insert(pos, msg)
        self.payload_queue.insert(pos, payload)
        self.msg_name_queue.insert(pos, msg_name)
        # Transmit first entry in queue if it is full
        if len(self.msg_queue) > MSG_QUEUE_SIZE or process:
            self.process_msg_queue()
            
            
    def process_msg_queue(self, clear=False):
        """Process message queue by sending first entry at a minimum and the entire queue if so 
        specified.
        
        Args:
            clear (bool)
                Indicates whether or not to process entire queue. Defaults to False.
        """
        # Determine how many to send based on 
        num_to_send = len(self.msg_queue) if clear else 1
        for _ in range(num_to_send):
            self.send_msg_count += 1
            # Take first element from each queue
            msg = self.msg_queue.pop(0)
            payload = self.payload_queue.pop(0)
            msg_name = self.msg_name_queue.pop(0)
            self.msg_id_order.append(payload['message_id'])
            # Advertise message was sent for "realism"
            self.logger.info(f"SEND MESSAGE #{self.send_msg_count} --> {msg_name}.")
            self.logger.debug(f"Encoded payload --> {payload}")
            # Account for dropped MRM_SCAN_INFO message probability
            drop_msg = self.rng.binomial(1, self.drop_msg_prob)
            if self.op_mode == 'test' and msg_name == 'MRM_SCAN_INFO' and drop_msg:
                self.dropped_msg_ids.append(payload['message_id'])
            elif self.op_mode == 'real' and drop_msg:
                self.dropped_msg_ids.append(payload['message_id'])
            else:
                self.connection['socket'].sendto(msg, self.connection['host_address'])
                
                
    def clear_msg_queue(self):
        """Clear message queue without sending any messages."""
        
    
    def listen_and_respond(self):
        """Listen and respond to messages from host.
        
        Raises:
            ConnectionError if emulator is not open.
            NotImplementedError if response to message's type is not implemented.
        """
        if self.open:
            self.logger.state("READY to respond to requests.")
            while True:
                # Wait for message from host under set timeout constraint
                msg, host_address = self.connection['socket'].recvfrom(MAX_PACKET_SIZE)
                self.receive_msg_count += 1
                self.logger.debug("RECEIVED data; attempting to decode...")
                
                # Set the host address if not yet done so
                if self.connection['host_address'] is None:
                    self.connection['host_address'] = host_address
                    self.logger.debug(f"Host address --> {host_address}.")
                    
                # Decode message
                request_name, request_payload, request_status = self.decode_msg(msg)
                self.logger.info(f"RECEIVE MESSAGE #{self.receive_msg_count} --> {request_name}.")
                self.logger.debug(f"Decoded payload --> {request_payload}")
                
                # Determine appropriate response
                if request_name == 'MRM_SET_CONFIG_REQUEST':
                    self.set_radar_config_request_response(request_payload, request_status)
                elif request_name == 'MRM_GET_CONFIG_REQUEST':
                    self.get_radar_config_request_response(request_payload, request_status)
                elif request_name == 'MRM_CONTROL_REQUEST':
                    self.control_request_response(request_payload, request_status)
                elif request_name == 'MRM_REBOOT_REQUEST':
                    self.reboot_request_response(request_payload, request_status)
                elif request_name == 'MRM_GET_STATUSINFO_REQUEST':
                    self.get_statusinfo_request_response(request_payload, request_status)
                elif request_name == 'MRM_COMM_CHECK_REQUEST':
                    self.comm_check_request_response(request_payload, request_status)
                else:
                    raise NotImplementedError(f"Message's apparent type {request_payload['message_type']}"
                                            " does not have a response implemented!")
        else:
            raise ConnectionError("Emulator connection not open; cannot listen for or send messages!")
        
        
    def set_radar_config_request_response(self, request_payload, request_status):
        """Respond to set radar configuration request from host by updating configuration and 
        sending confirmation message.
        
        Args:
            request_payload (OrderedDict)
                Payload decoded from MRM_SET_CONFIG_REQUEST from host. Used to configure certain 
                portions of response message.
                
            request_status (int)
                Status of request as thus far determined by its decoding.
        """
        self.logger.state("CONFIGURATION SET request received...")
        # Initialize confirm payload from format
        confirm_payload = \
            self.init_confirm_payload(request_payload, request_status, 'MRM_SET_CONFIG_CONFIRM')
            
        # Only update configuration if request was successful
        if request_status != 0:
            self.logger.state("FAILED to set configuration!")
            self.logger.debug(f"MRM_SET_CONFIG_REQUEST has non-successful status {request_status}; "
                              "no configuration will be set.")
            
        else:
            # Additional check(s) on specified configuration
            if request_payload['scan_start'] >= request_payload['scan_stop']:
                confirm_payload['status'] = 3
            # Update config
            else:
                self.config = OrderedDict([(key, request_payload[key]) for key in DEFAULT_CONFIG])
            
        # Encode and send response
        self.logger.state('CONFIGURATION SET.')
        self.queue_msg(confirm_payload, 'MRM_SET_CONFIG_CONFIRM')
        self.process_msg_queue()
        
        
    def get_radar_config_request_response(self, request_payload, request_status):
        """Respond to get radar configuration request from host by sending current configuration.
        
        Args:
            request_payload (OrderedDict)
                Payload decoded from MRM_GET_CONFIG_REQUEST from host. Used to configure certain 
                portions of response message.
                
            request_status (int)
                Status of request as thus far determined by its decoding.
        """
        self.logger.state("CONFIGURATION GET request received...")
        # Initialize confirm payload from format
        confirm_payload = \
            self.init_confirm_payload(request_payload, request_status, 'MRM_GET_CONFIG_CONFIRM')
        
        # Only report status if request successful
        if request_status != 0:
            self.logger.state("FAILED to get configuration!")
            self.logger.debug(f"MRM_GET_CONFIG_REQUEST has non-successful status {request_status}; "
                              "no configuration will be sent.")
            
        # Update payload
        else:
            confirm_payload.update(self.config)
            confirm_payload['timestamp'] = int((time.time() * 1000) - self.boot_time)
            
        # Encode and send response
        self.logger.state("CONFIGURATION SENT.")
        self.queue_msg(confirm_payload, 'MRM_GET_CONFIG_CONFIRM')
        self.process_msg_queue()
        
        
    def control_request_response(self, request_payload, request_status):
        """Respond to control request from host by sending confirmation message and then sending
        specified scan data.
        
        Args:
            request_payload (OrderedDict)
                Payload decoded from MRM_CONTROL_REQUEST from host. Used to configure certain 
                portions of response message.
                
            request_status (int)
                Status of request as thus far determined by its decoding.
        """
        self.logger.state("COLLECTION REQUEST received...")
        # Initialize confirm payload from format, set it, and queue it
        confirm_payload = \
            self.init_confirm_payload(request_payload, request_status, 'MRM_CONTROL_CONFIRM')
        self.queue_msg(confirm_payload, 'MRM_CONTROL_CONFIRM')
        self.process_msg_queue()
        
        # Only command scans if request was successful
        if request_status != 0:
            self.logger.state("FAILED to execute collection request!")
            self.logger.debug(f"MRM_CONTROL_REQUEST has non-successful status {request_status}; no "
                              "scans will be made.")
            # Encode and send response
            self.process_msg_queue(clear=True)
        
        # Only command scans if scan request was successful
        else:
            # Retrieve configuration information from scan request
            self.scan_count = request_payload['scan_count']
            self.start_msg_id = request_payload['message_id']
            # Compute scan settings and initialize MRM_SCAN_INFO payloads
            self.compute_scan_settings(request_payload)
            scan_payload = self.init_scan_payloads()
            # Compute platform positions
            self.compute_platform_pos()
            # Compute radar data
            self.compute_radar_data()
            
            # Finite number of scans
            self.logger.state("COLLECTING...")
            if self.scan_count != FOREVER_SCAN_COUNT:
                self.finite_scan(scan_payload)
            # Scan forever until stop signal comes
            else:
                self.continuous_scan(scan_payload)
            # Clear the message buffer and save out any needed data
            self.process_msg_queue(clear=True)
            self.save_platform_pos()
            self.logger.state("COLLECTION DONE.")
            
            
    def compute_scan_settings(self, request_payload):
        """Compute scan settings based on provided configuration.
        
        Args:
            request_payload (OrderedDict)
                Payload decoded from MRM_GET_CONFIG_REQUEST from host. Used to configure certain 
                portions of response message.
        """
        # Signal gain
        self.tx_gain = TX_GAIN_MAP[self.config['tx_gain_ind']]
        self.int_gain = 2**(self.config['pii'] - MIN_PII)
        self.total_gain = self.tx_gain * self.int_gain
        # Scan duration
        scan_duration = self.config['scan_stop'] - self.config['scan_start']
        num_windows = math.ceil(scan_duration / self.sampling_window)
        self.scan_stop = math.ceil(self.config['scan_start'] + num_windows * self.sampling_window)
        # Number of samples
        self.num_samples_total = math.ceil((num_windows * self.sampling_window) / (T_BIN * 1e3))
        self.num_msgs_per_scan = math.ceil(self.num_samples_total / SEG_NUM_BINS)
        self.num_samples_per_msg = [int(SEG_NUM_BINS)] * self.num_msgs_per_scan
        if self.num_samples_total != sum(self.num_samples_per_msg):
            self.num_samples_per_msg[-1] = self.num_samples_total - sum(self.num_samples_per_msg[:-1])
        # Range bins
        self.range_start = SPEED_OF_LIGHT * (self.config['scan_start'] * 1e-12) / 2
        self.range_bin_size = SPEED_OF_LIGHT * T_BIN * 1e-9 / 2
        self.range_bins = self.range_start + self.range_bin_size * np.arange(0, self.num_samples_total)
        sample_intervals = np.insert(np.cumsum(self.num_samples_per_msg), 0, 0)
        for per_scan_msg_idx in range(self.num_msgs_per_scan):
            self.range_bin_idx.append(
                np.arange(sample_intervals[per_scan_msg_idx], sample_intervals[per_scan_msg_idx + 1]))
            self.range_bins_per_msg.append(
                self.range_start + self.range_bin_size * self.range_bin_idx[per_scan_msg_idx])
        # Scan interval
        min_scan_interval = \
            (2**self.config['pii'] * self.rake_steps_per_window * num_windows) / IMPULSE_RATE
        if (request_payload['scan_interval'] * 1e-6) < min_scan_interval:
            self.scan_interval = min_scan_interval
        else:
            self.scan_interval = request_payload['scan_interval'] * 1e-6
            
            
    def init_scan_payloads(self):
        """Initialize scan payloads by setting static portions.
        
        Returns:
            scan_payload (OrderedDict)
                Initialized scan payload.
        """
        scan_payload = OrderedDict.fromkeys(ALL_MRM_MESSAGES['MRM_SCAN_INFO']['packet_def'])
        scan_payload['message_type'] = ALL_MRM_MESSAGES['MRM_SCAN_INFO']['message_type']
        scan_payload['node_id'] = self.config['node_id']
        scan_payload['reserved0'] = RESERVED_VAL
        scan_payload['reserved1'] = RESERVED_VAL
        scan_payload['reserved2'] = RESERVED_VAL
        scan_payload['reserved3'] = RESERVED_VAL
        scan_payload['scan_start'] = self.config['scan_start']
        scan_payload['scan_stop'] = self.scan_stop
        scan_payload['scan_res'] = self.config['scan_res']
        scan_payload['scan_type'] = 1
        scan_payload['reserved4'] = RESERVED_VAL
        scan_payload['antenna_id'] = 0 if self.config['ant_mode'] == 2 else 1
        scan_payload['operational_mode'] = 1
        scan_payload['num_samples_total'] = self.num_samples_total
        scan_payload['num_messages_total'] = self.num_msgs_per_scan
        return scan_payload
    
    
    def compute_platform_pos(self):
        """Compute platform positions based on data mode."""
        # Real-time data mode
        if self.data_mode == 'realtime':
            self.platform_pos, self.radar_heading = parse_mission(self.mission, self.scan_interval)
            self.realtime_max_num_scans = self.platform_pos.shape[0]
            
            
    def compute_radar_data(self):
        """Generate radar data based on data mode."""
        # Real-time data mode
        if self.data_mode == 'realtime':
            # # Sampling
            t = 2 * self.range_bins / SPEED_OF_LIGHT
            # Populate scan data
            self.realtime_scan_data = np.zeros((self.realtime_max_num_scans, self.num_samples_total))
            for scan_idx in range(self.realtime_max_num_scans):
                # Determine which scatterers are within the radar beam
                radar_to_scatterers_vec = \
                    self.scatterers['pos_rcs'][:, :-2] - self.platform_pos[scan_idx, :-1]
                one_way_range = np.linalg.norm(radar_to_scatterers_vec, axis=1)[:, np.newaxis]
                radar_to_scatterers_vec = radar_to_scatterers_vec / one_way_range
                scatterers_az = \
                    np.abs(np.arccos(np.dot(radar_to_scatterers_vec, self.radar_heading[scan_idx, :-1])))
                visible_scatterers = np.nonzero(scatterers_az <= self.mission['beamwidth'] / 2)
                if visible_scatterers[0].size > 0:
                    one_way_range = one_way_range[visible_scatterers]
                    # Account for propagation loss if specified
                    if self.prop_loss:
                        prop_loss = 1 / (one_way_range**4)
                    else:
                        prop_loss = np.ones_like(one_way_range)
                    # Compute the sum response from visible scatterers
                    scatterer_time_delays = 2 * one_way_range / SPEED_OF_LIGHT
                    scan_data = t - scatterer_time_delays
                    scan_data *= self.scatterers['bandwidth']
                    scan_data = np.sinc(scan_data)
                    scan_data *= self.scatterers['pos_rcs'][visible_scatterers, -1].T
                    scan_data *= prop_loss
                    self.realtime_scan_data[scan_idx, :] = np.sum(scan_data, axis=0)
                
                
    def save_platform_pos(self):
        """Save platform positions to file if needed by data mode."""
        if self.data_mode in ['offline', 'realtime']:
            # Offline data mode platform positions are computed in post
            if self.data_mode == 'offline':
                scan_timestamps = self.scan_interval * np.arange(self.num_scans)
                self.platform_pos = self.offline_platform_pos_interp(scan_timestamps)
            # Realtime data mode
            elif self.data_mode == 'realtime':
                self.platform_pos = self.platform_pos[:self.num_scans, :]
            # Save to file
            with open(self.platform_pos_file, 'wb') as f:
                pickle.dump({'platform_pos': self.platform_pos}, f)
            
            
    def finite_scan(self, scan_payload):
        """Finite number of scans.
        
        Args:
            scan_payload (OrderedDict)
                Pre-initialized scan payload. All fields constant over a given scan request must be 
                populated with desired values.
        """
        # Initialize payload buffer to allow for out-of-order message/packet simulation
        payload_buffer_size = min(OUT_OF_ORDER_WINDOW, self.num_msgs_per_scan)
        payload_buffer = []
        payload_count = 0
        self.prev_amp = -1 * self.total_gain
        self.num_scans = self.scan_count
        start_timestamp = int((time.time() * 1000) - self.boot_time)
        
        # Loop over each scan and message/packet
        for scan_idx in range(self.scan_count):
            scan_timestamp = int(scan_idx * self.scan_interval * 1e3) + start_timestamp
            for per_scan_msg_idx in range(self.num_msgs_per_scan):
                # Current message's ID
                payload_count += 1
                msg_id = (self.start_msg_id + payload_count) % (MAX_MSG_ID + 1)
                # Populate dynamic parts of scan payload
                scan_payload['scan_data'] = self.generate_msg_scan_data(
                    self.num_samples_per_msg[per_scan_msg_idx], scan_idx, per_scan_msg_idx)
                scan_payload['message_id'] = msg_id
                scan_payload['timestamp'] = scan_timestamp
                scan_payload['num_samples_message'] = self.num_samples_per_msg[per_scan_msg_idx]
                scan_payload['message_index'] = per_scan_msg_idx
                # Update payload buffer
                payload_buffer.append(deepcopy(scan_payload))
                
                # If payload buffer has filled, start queuing them to be sent
                if len(payload_buffer) >= payload_buffer_size:
                    if self.rng.binomial(1, self.out_of_order_msg_prob):
                        swap_idx = self.rng.integers(1, payload_buffer_size)
                        payload_buffer[0], payload_buffer[swap_idx] = \
                            payload_buffer[swap_idx], payload_buffer[0]
                    self.queue_msg(payload_buffer.pop(0), 'MRM_SCAN_INFO')
        
        # Queue up the payloads still in the buffer
        for _ in range(len(payload_buffer)):
            if self.rng.binomial(1, self.out_of_order_msg_prob):
                swap_idx = self.rng.integers(1, len(payload_buffer))
                payload_buffer[0], payload_buffer[swap_idx] = \
                    payload_buffer[swap_idx], payload_buffer[0]
            self.queue_msg(payload_buffer.pop(0), 'MRM_SCAN_INFO')
            
            
    def continuous_scan(self, scan_payload):
        """Scan until commanded to stop.
        
        Args:
            scan_payload (OrderedDict)
                Pre-initialized scan payload. All fields constant over a given scan request must be 
                populated with desired values.
        """
        # Initialize packet buffer to allow for out-of-order packet simulation
        payload_count = 0
        scan_idx = 0
        self.prev_amp = -1 * self.total_gain
        stop_flag = False
        self.connection['socket'].settimeout(0)
        start_timestamp = int((time.time() * 1000) - self.boot_time)
        
        # Collect until stop is commanded
        while not stop_flag:
            scan_timestamp = int(scan_idx * self.scan_interval * 1e3) + start_timestamp
            payload_buffer = []
            # Generate scan on a message-by-message basis
            for per_scan_msg_idx in range(self.num_msgs_per_scan):
                # Current message's ID
                payload_count += 1
                msg_id = (self.start_msg_id + payload_count) % (MAX_MSG_ID + 1)
                
                # Populate dynamic parts of scan payload
                scan_payload['scan_data'] = self.generate_msg_scan_data(
                    self.num_samples_per_msg[per_scan_msg_idx], scan_idx, per_scan_msg_idx)
                scan_payload['message_id'] = msg_id
                scan_payload['timestamp'] = scan_timestamp
                scan_payload['num_samples_message'] = self.num_samples_per_msg[per_scan_msg_idx]
                scan_payload['message_index'] = per_scan_msg_idx
                payload_buffer.append(deepcopy(scan_payload))
                
            # Model specified out-of-order packet arrival probability and queue scan messages
            for per_scan_msg_idx in range(self.num_msgs_per_scan - 1):
                if self.rng.binomial(1, self.out_of_order_msg_prob):
                    swap_idx = self.rng.integers(per_scan_msg_idx + 1, self.num_msgs_per_scan)
                    payload_buffer[per_scan_msg_idx], payload_buffer[swap_idx] = \
                        payload_buffer[swap_idx], payload_buffer[per_scan_msg_idx]
                self.queue_msg(payload_buffer[per_scan_msg_idx], 'MRM_SCAN_INFO')
            self.queue_msg(payload_buffer[-1], 'MRM_SCAN_INFO')
                    
            # Transmit current scan's messages
            self.process_msg_queue(clear=True)
                
            # Check for stop scan message
            try:
                msg, _ = self.connection['socket'].recvfrom(MAX_PACKET_SIZE)
                self.receive_msg_count += 1
                stop_name, stop_payload, stop_status = self.decode_msg(msg)
                self.logger.info(f"RECEIVE MESSAGE #{self.receive_msg_count} --> "
                                    f"{stop_name}.")
                self.logger.debug(f"Decoded payload --> {stop_payload}")
                if stop_name != "MRM_CONTROL_REQUEST":
                    self.logger.debug("Ignoring message due to active collection.")
                else:
                    response_payload = self.init_confirm_payload(stop_payload, 
                                                                    stop_status, 
                                                                    'MRM_CONTROL_CONFIRM')
                    if stop_status == 0:
                        if stop_payload['scan_count'] == STOP_SCAN_COUNT:
                            stop_flag = True
                            self.connection['socket'].settimeout(self.idle_timeout)
                        else:
                            self.logger.debug("Ignoring new MRM_CONTROL_REQUEST due to "
                                                "active collection.")
                            response_payload['status'] = 6
                    self.queue_msg(response_payload, 'MRM_CONTROL_CONFIRM')
            except:
                pass
                    
            # Proceed to next scan
            scan_idx += 1
        self.num_scans = scan_idx
        
        
    def generate_msg_scan_data(self, num_samples, scan_idx, per_scan_msg_idx):
        """Generate single message's scan data.
        
        Args:
            num_samples (int)
                Number of samples to generate.
                
            scan_idx (int)
                Current scan index.
                
            per_scan_msg_idx (int)
                Current per-scan message index.
                
        Returns:
            msg_scan_data (list)
                Message's generated scan data.
        
        Raises:
            KeyError if unrecognized data mode is specified.
        """
        # BIT failure
        if self.bit_result != 0:
            msg_scan_data = [0] * num_samples
            
        # Normal operation
        else:
            # Constant; each scan gets a constant value that increases scan-by-scan
            if self.data_mode == 'constant':
                amp = (scan_idx - self.scan_wrap) * self.total_gain
                if amp > SCAN_DATA_MAX:
                    self.scan_wrap = scan_idx
                    amp = (scan_idx - self.scan_wrap) * self.total_gain
                sign = 1 if self.rng.random() < 0.5 else -1
                msg_scan_data = [sign * amp] * num_samples
                
            # Ramp; each scan message gets a constant value that increases scan message-by-scan message
            elif self.data_mode == 'ramp':
                amp = self.prev_amp + self.amp_dir * self.total_gain
                if abs(amp) > SCAN_DATA_MAX:
                    self.amp_dir *= -1
                    amp = self.prev_amp + self.amp_dir * self.total_gain
                self.prev_amp = deepcopy(amp)
                sign = 1 if self.rng.random() < 0.5 else -1
                msg_scan_data = [sign * amp] * num_samples
                
            # Offline or real-time
            elif self.data_mode in ['offline', 'realtime']:
                # Offline; interpolate from offline radar data
                if self.data_mode == 'offline':
                    msg_scan_data = self.offline_data_interp(self.range_bins_per_msg[per_scan_msg_idx], 
                                                             scan_idx * self.scan_interval)
                
                # Real-time; generate from specified scatterers
                elif self.data_mode == 'realtime':
                    if scan_idx < self.realtime_max_num_scans:
                        msg_scan_data = \
                            self.realtime_scan_data[scan_idx, self.range_bin_idx[per_scan_msg_idx]]
                    else:
                        msg_scan_data = \
                            self.realtime_scan_data[-1, self.range_bin_idx[per_scan_msg_idx]]
                        if self.platform_pos.shape[0] <= scan_idx:
                            self.platform_pos = np.append(self.platform_pos, 
                                                          np.atleast_2d(self.platform_pos[-1, :]), 
                                                          axis=0)
                    
                # Factor in total gain
                msg_scan_data *= self.total_gain
                # Add noise if requested
                if self.add_noise:
                    msg_scan_data += self.rng.normal(loc=0, 
                                                     scale=(self.tx_gain * self.noise_var), 
                                                     size=num_samples)
            
            # Unknown
            else:
                raise KeyError(f"Unrecognized data mode of '{self.data_mode}' specified!")
            
        # Enforce int32 type
        msg_scan_data = np.clip(msg_scan_data, SCAN_DATA_MIN, SCAN_DATA_MAX)
        msg_scan_data = np.round(msg_scan_data)
        msg_scan_data = list(map(int, msg_scan_data))
        return msg_scan_data


    def reboot_request_response(self, request_payload, request_status):
        """"Respond to reboot request from host by "rebooting" emulator.
        
        Args:
            request_payload (OrderedDict)
                Payload decoded from MRM_REBOOT_REQUEST from host. Used to configure certain 
                portions of response message.
                
            request_status (int)
                Status of request as thus far determined by its decoding.
        """
        self.logger.state("REBOOT request received...")
        # Initialize confirm payload from format
        confirm_payload = \
            self.init_confirm_payload(request_payload, request_status, 'MRM_REBOOT_CONFIRM')
            
        # Only reboot if request successful
        if request_status != 0:
            self.logger.state("FAILED to reboot!")
            self.logger.debug(f"MRM_REBOOT_REQUEST has non-successful status {request_status}; no "
                              "reboot will be performed.")
            # Encode and send response
            self.queue_msg(confirm_payload, 'MRM_REBOOT_CONFIRM')
            self.process_msg_queue()
        
        # Update payload
        else:
            # Encode and send response
            self.queue_msg(confirm_payload, 'MRM_REBOOT_CONFIRM')
            self.process_msg_queue()
            self.logger.state("REBOOTING...")
            # Reboot emulator
            self.close_connection()
            if not self.config['persist_flag']:
                self.config = DEFAULT_CONFIG
            self.boot()
            
            
    def get_statusinfo_request_response(self, request_payload, request_status):
        """"Respond to get status info request from host by sending status.
        
        Args:
            request_payload (OrderedDict)
                Payload decoded from MRM_GET_STATUSINFO_REQUEST from host. Used to configure certain 
                portions of response message.
                
            request_status (int)
                Status of request as thus far determined by its decoding.
        """
        self.logger.state("STATUS GET request received...")
        # Initialize confirm payload from format
        confirm_payload = \
            self.init_confirm_payload(request_payload, request_status, 'MRM_GET_STATUSINFO_CONFIRM')
            
        # Only report status if request successful
        if request_status != 0:
            self.logger.state("FAILED to send status!")
            self.logger.debug(f"MRM_GET_STATUSINFO_REQUEST has non-successful status {request_status};"
                              "no radar status will be reported.")
        
        # Update payload
        else:
            confirm_payload.update(self.status)
            confirm_payload['bit_result'] = self.bit_result
            
        # Encode and send response
        self.logger.state("STATUS SENT.")
        self.queue_msg(confirm_payload, 'MRM_GET_STATUSINFO_CONFIRM')
        self.process_msg_queue()
        
        
    def comm_check_request_response(self, request_payload, request_status):
        """"Respond to communication check from host by parroting request payload and appending 
        current datestring.
        
        Args:
            request_payload (OrderedDict)
                Payload decoded from MRM_COMM_CHECK_REQUEST from host. Used to configure certain 
                portions of response message.
                
            request_status (int)
                Status of request as thus far determined by its decoding.
        """
        self.logger.state("COMMUNICATION CHECK request received...")
        # Initialize confirm payload from format
        confirm_payload = \
            self.init_confirm_payload(request_payload, request_status, 'MRM_COMM_CHECK_CONFIRM')
            
        # Only send check back if request was successful
        if request_status != 0:
            self.logger.state("FAILED to perform communication check!")
            self.logger.debug(f"MRM_COMM_CHECK_REQUEST has non-successful status {request_status}; "
                              "no communication check will be performed.")
            
        # Update payload
        else:
            # Compute dynamic field(s) of confirm payload
            ref_datetime = datetime.datetime.now()
            datetime_str = ref_datetime.strftime('%Y%m%dT%H%M%S')
            datetime_str = [ord(character) for character in datetime_str]
            # Set confirm payload
            confirm_payload['uint8_val'] = request_payload['uint8_val']
            confirm_payload['uint16_val'] = request_payload['uint16_val']
            confirm_payload['uint32_val'] = request_payload['uint32_val']
            confirm_payload['int8_val'] = request_payload['int8_val']
            confirm_payload['int16_val'] = request_payload['int16_val']
            confirm_payload['int32_val'] = request_payload['int32_val']
            confirm_payload['datetime_str'] = datetime_str
            
        # Encode and send response
        self.logger.state("COMMUNICATION CHECK completed.")
        self.queue_msg(confirm_payload, 'MRM_COMM_CHECK_CONFIRM')
        self.process_msg_queue()
        
        
    def report_summary(self):
        """Report emulator action summary."""
        self.logger.reference("Messages, as identified by message ID, were sent in following order "
                              f"--> {self.msg_id_order}")
        self.logger.reference("Following messages, as identified by message ID, were dropped --> "
                              f"{self.dropped_msg_ids}")
        if self.data_mode in ['offline', 'realtime']:
            self.logger.reference(f"Saved platform positions to '{self.platform_pos_file}'.")
        
        
def check_for_file(file):
    """Checks for file at both path specified and in INPUT_DIR.
    
    Args:
        file (str)
            Path (absolute or relative) to file of interest.
            
    Returns:
        file (str)
            Path (absolute) to file of interest if found at either specified location or in 
            INPUT_DIR.
            
    Raises:
        FileNotFoundError if file not found at path specified or in INPUT_DIR.
    """
    file = Path(file).resolve()
    # Check if file exists at specified path
    if not file.exists():
        # Check if file exists in INPUT_DIR
        file = INPUT_DIR.joinpath(file.name).resolve()
        if not file.exists():
            raise FileNotFoundError(f"'{file.name}' cannot be found at path specified or in input "
                                    f"directory '{INPUT_DIR}'!")
    return file.as_posix()


def parse_args(args):
    """Input argument parser.
    
    Args:
        args (list)
            Input arguments as taken from command line execution via sys.argv[1:].
        
        cmd_line (bool)
            Indicates whether or not method was called via command line.
    
    Returns:
        parsed_args (namespace)
            Parsed arguments.
            
    Raises:
        ArgumentParser.error if 'offline_data' not specified in 'offline' data mode.
        ArgumentParser.error if 'scatterers' not specified in 'realtime' data mode.
        ArgumentParser.error if 'mission' not specified in 'realtime' data mode.
    """
    parser = argparse.ArgumentParser(description=("PulsON 440 emulator. Designed to represent the "
                                                  "interactions between a host (computer) and a "
                                                  "PulsON 440 radar over UDP communications."))
    parser.add_argument('-op', '--op_mode', nargs='?', type=str,
                        choices=('develop', 'test', 'real'), default='develop', const='develop', 
                        help=("Emulator operation mode. Options are {'develop', 'test', 'real'}. "
                              "'develop' runs the emulator under ideal assumptions without any of "
                              "the error models. 'test' runs the emulator with error models; "
                              "packet related error models are applied only to MRM_SCAN_INFO "
                              "messages. 'real' runs the emulator with the error models; packet "
                              "related errors are applied to all messages. Defaults to "
                              "'develop'."))
    parser.add_argument('-dm', '--data_mode', nargs='?', type=str, default='ramp', const='ramp',
                        choices=('constant', 'ramp', 'offline', 'realtime'), 
                        help=("Radar data generation mode. Options are {'constant', 'ramp', "
                              "'offline', 'realtime}. 'constant' generates data that linearly "
                              "increases on a scan-by-scan basis. 'ramp' generates data that "
                              "linearly increases on a MRM_SCAN_INFO message-by-message basis. "
                              "'offline' generates data based on data specified by the "
                              "'--offline_data' argument. 'realtime' generates data based on "
                              "real-time calculation of signals from point scatterers specified "
                              "by the '--scatterers' argument. Defaults to 'ramp'."))
    parser.add_argument('-od', '--offline_data', nargs='?', type=str, default='', const='', 
                        help=("Path (relative or absolute) to offline data file. Must be specified "
                              "if 'offline' is specified for '--data_mode' argument. If path "
                              f"cannot be immediately resolved, will look in '{INPUT_DIR}' for "
                              "file; this behavior can be used to centralize input files. File "
                              "must be a pickle containing data in the format produced by "
                              "'simulate_sar_data.py`." ))
    parser.add_argument('-s', '--scatterers', nargs='?', type=str, 
                        default=DEFAULT_SCATTERERS, const=DEFAULT_SCATTERERS, 
                        help=("Path (relative or absolute) to file specifying scatterers. Must be "
                              "specified if 'realtime' is specified for '--data mode' argument. "
                              f"If path cannot be immediately resolved, will look in {INPUT_DIR}' "
                              "for file; this behavior can be used to centralize input files. "
                              "File must be a YAML whose contents are formatted in accordance to "
                              "the README. Defaults to '{DEFAULT_SCATTERERS}'."))
    parser.add_argument('-m', '--mission', nargs='?', type=str, 
                        default=DEFAULT_MISSION, const=DEFAULT_MISSION,
                        help=("Path (relative or absolute) to file specifying mission, i.e., "
                              "platform path waypoints, velocities, radar orientation, and "
                              "regions-of-interest. Must be specified if 'realtime' is specified "
                              "for '--data mode' argument. If path cannot be immediately resolved, "
                              f"will look in '{INPUT_DIR}' for file; this behavior can be used to "
                              "centralize input files. File must be YAML whose contents are "
                              "formatted in accordance to the README. Defaults to "
                              f"'{DEFAULT_MISSION}'."))
    parser.add_argument('-t', '--timeout', type=int, default=IDLE_TIMEOUT,
                        help=("Amount of time (s) for emulator to idle (i.e., receiving no "
                              "messages from host) before shutting down. Defaults to "
                              f"{IDLE_TIMEOUT}"))
    parser.add_argument('--ip', nargs='?', type=str, const=RADAR_IP, default=RADAR_IP,
                        help=("IP address to use for emulator. Only 'localhost' or equivalently "
                              f"'127.0.0.1' are known to reliably work. Defaults to '{RADAR_IP}'."))
    parser.add_argument('-p', '--port', type=int, default=RADAR_PORT,
                        help=("Port to use for emulator. Specified port must not conflict with any "
                              "other network activity. Ports above 10000 are generally considered "
                              "safe/available but developer should confirm before using. Defaults "
                              f"to {RADAR_PORT}."))
    parser.add_argument('-an', '--add_noise', action='store_true', 
                        help=("Include Additive White Gaussian Noise (AWGN) noise to radar data "
                              "generated when either 'offline' or 'realtime' specified for "
                              "'--data_mode' argument."))
    parser.add_argument('-nm', '--noise_mag', type=float, default=2**(MIN_PII - 1), 
                        help=f"Magnitude of AWGN noise. Defaults to {2**(MIN_PII - 1)}.")
    parser.add_argument('-pl', '--prop_loss', action='store_true', 
                        help="Include range propagation loss.")
    parser.add_argument('-br', '--beam_rolloff', action='store_true', help="Include beam rolloff.")
    parser.add_argument('-bit', '--bit_prob', type=float, default=BIT_FAIL_PROB, 
                        help=("BIT failure probability. Must be in range [0, 1] inclusive. "
                              f"Defaults to {BIT_FAIL_PROB}."))
    parser.add_argument('-drop', '--drop_prob', type=float, default=DROP_MSG_PROB, 
                        help=("Dropped message/packet probability. Must be in range [0, 1] "
                              f"inclusive. Defaults to {DROP_MSG_PROB}."))
    parser.add_argument('-order', '--order_prob', type=float, default=OUT_OF_ORDER_MSG_PROB, 
                        help=("Out-of-order message/packet arrival probability. Must be in range "
                              f"[0, 1] inclusive. Defaults to {OUT_OF_ORDER_MSG_PROB}."))
    parsed_args = parser.parse_args(args)
    
    # Make sure required argument pairs are present
    if parsed_args.data_mode == 'offline':
        if parsed_args.offline_data == '':
            parser.error("argument --offline_data: must be specified if running w/ argument "
                         "'--data_mode offline'.")
        else:
            parsed_args.offline_data = check_for_file(parsed_args.offline_data)
            
    if parsed_args.data_mode == 'realtime':
        if parsed_args.scatterers == '':
            parser.error("argument --scatterers: must be specified if running w/ argument "
                         "'--data_mode realtime'.")
        else:
            parsed_args.scatterers = check_for_file(parsed_args.scatterers)
        if parsed_args.mission == '':
            parser.error("argument --mission: must be specified if running w/ argument "
                         "'--data_mode realtime'.")
        else:
            parsed_args.mission = check_for_file(parsed_args.mission)
    
    return parsed_args


def main(args):
    """Main execution method to run emulator.
    
    Args:
        args (list)
            Input arguments as taken from command line execution via sys.argv[1:].
    """

    # Logger setup
    logger_config_filepath = (CONFIG_DIR / 'logger_config.yml').resolve().as_posix()
    with open(logger_config_filepath, 'r') as f:
        logger_config = yaml.load(f, Loader=yaml.FullLoader)
    logger = setup_logger(name=logger_config['name'], config=logger_config['config'])

    # Parse input arguments
    parsed_args = parse_args(args)
    logger.state("STARTING emulator...")
    logger.state("WAIT for readiness confirmation...")
    logger.debug(f"Arguments --> {parsed_args}")
    
    try:
        # Initialization and boot
        emulator = Emulator(logger=logger, 
                            op_mode=parsed_args.op_mode, 
                            data_mode=parsed_args.data_mode, 
                            offline_data=parsed_args.offline_data,
                            scatterers=parsed_args.scatterers,
                            mission=parsed_args.mission,
                            idle_timeout=parsed_args.timeout, 
                            emulator_ip=parsed_args.ip, 
                            emulator_port=parsed_args.port, 
                            add_noise=parsed_args.add_noise, 
                            noise_mag=parsed_args.noise_mag,
                            prop_loss=parsed_args.prop_loss,
                            beam_rolloff=parsed_args.beam_rolloff,
                            bit_fail_prob=parsed_args.bit_prob, 
                            drop_msg_prob=parsed_args.drop_prob,
                            out_of_order_msg_prob=parsed_args.order_prob)
        emulator.boot()
        
        # Listen and respond appropriately
        emulator.listen_and_respond()
        
    except socket.timeout:
        logger.state(f"TIMED OUT; emulator idle timeout of {emulator.idle_timeout} seconds "
                     "exceeded; emulator will shut down.")
        
    except Exception:
        logger.exception("FATAL EXCEPTION ENCOUNTERED!")
        
    # Close connection
    finally:
        emulator.report_summary()
        logger.state("SHUTTING DOWN emulator...")
        emulator.close_connection()
        logger.state("SHUT DOWN complete.")
        close_logger(logger)
        
        
if __name__ == '__main__':
    """Standard Python alias for command line execution."""
    main(sys.argv[1:])
